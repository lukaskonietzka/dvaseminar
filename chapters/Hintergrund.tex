\chapter{Hintergrund und Grundlagen}
Dieses Kapitel soll die Grundsteine legen und in die Konzepte und Theorien der Analyse-Erweiterungen
einführen. Um die Fragestellung dieser Arbeit einordnen zu können, ist unter anderem
ein Blick auf die Historie hilfreich. Der Hauptgrund für die Wahl der drei oben
genannten Erweiterungen liegt nämlich nicht nur in ihren vielseitigen
Möglichkeiten, sondern auch in ihrer Integration in den SQL-Standard, wie auch
von \cite{grust2017advanced} in seiner Arbeit hervorgehoben wird. Er verdeutlicht
auf Seite 10, dass im Jahre 1987 die erste Version des SQL-Standards
veröffentlicht wurde. Mit SQL3 1999 kamen dann die ersten Analyse-Erweiterungen mit
den \textit{recursive queries} hinzu. Wie \cite{melton2001sql} in Kapitel 9.12 ihrer
Arbeit beschreiben, wurden die Funktionen \textit{ROLLUP} und \textit{CUBE}
ebenfalls 1999 in den SQL-Standard aufgenommen. Die \textit{Window Functions}
hingegen folgten laut \cite{grust2017advanced} erst mit der späteren Version im
Jahr 2003.

\section{SQL Kurzüberischt}
Wird nur ausgeschrieben, wenn wir nicht genug Seiten haben

\section{Window Functions}
Die \textit{Analytic Functions} oder auch \textit{Window Functions} genannt,
sind das Herzstück der Analyse-Erweiterungen und somit auch für die Datenanalyse
innerhalb von SQL ein wichtiger Bestandteil. \cite{cao2012optimization} veröffentlichte
eine Arbeit über die Optimierung von \textit{Window Functions} wo er bereits zu
Beginn der Arbeit erwähnt, dass für eine Komplexe Datenanalyse diese SQL Erweiterungen
nicht mehr wegzudenken ist. Er beschreibt in seinem Artikel die \textit{Analytic
Functions} als repräsentativ für den aktuellen Stand der Technik.

Für eine pregnante und eindeutige Definition der \textit{Analytic Functions} sei
auf die Dokumentation der Oracle Datenbank verwiesen, die die \textit{Analytic
Functions} wie folgt beschreiben.

\begin{center}
	\textit{ 'Analytic functions compute an aggreagt value based on a grpoup of
	rows.' } \\ \cite{oracle}

	\textit{ 'The group of rows is called a window and is defined by the analytic-clause.'
	} \\ \cite{oracle}
\end{center}

Wenn man dieser Definition folgt, dann werden darunter also aggregierte Werte
verstanden, die mittels dem Schlüsselwort \texttt{OVER} auf bestimmte Zeilen in
einer Tabelle angewendet wird. So ist es Beispielsweise möglich, auch
benachbarte Datensätze mit einzubeziehen.

Die analytischen Funktionen sind stark verwandt mit den weit verbreiteten
Aggregatfunktionen in SQL. Sie bilden in gewisser Weise eine Erweiterung dieser Aggregatfunktionen.
\cite{Nuijten2023} betrachten zur Unterscheidung der Aggregatfunktion und den
analytischen Funktionen die Ergebnismenge. Sie erläutern, dass Beispielsweise
ein \texttt{COUNT(*)} als Aggregatfunktion nur eine Zeile zurückliefert, während
analytische Funktionen die Ergebnismenge nicht verändern und für jeden Eintrag
einen Wert angeben.

\cite{Nuijten2023} beschreiben weiter, dass sich die Abarbeitung der Funktionen in
drei Stufen einteilen lässt, wobei dir Sortierung dieser drei Schritte auch die
Reihenfolge der Abarbeitung festlegt.

\begin{description}
	\item[$\bullet$ 1. Stufe] auflösen der JOIN-, WHERE-, GROUP BY- und HAVING-Klausel

	\item[$\bullet$ 2. Stufe] die analytische Funktion wird auf die Ergebnismenge angewandt

	\item[$\bullet$ 3. Stufe] die ORDER BY-Klausel wir auf die Ergebnismenge angewandt
\end{description}

Im nächsten Abschnitt werden die Stufen zwei und drei genauer betrachtet und mittels
eines Modells verdeutlicht.

\subsection{Aufbau}
Um den Aufbau einer einfachen \textit{Window Function} etwas genauer verstehen
zu können, sei an dieser Stelle nochmals auf \cite{oracle} verwiesen. Hier ist
ein konkreter Aufbau einer analytischen Funktion zu finden, die hier näher betrachtet
werden soll.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.5]{img/aufbauAnalyticFunction.jpg}
	\caption{ Aufbau einer analytischen Funktion | Quelle: \cite{oracle}}
\end{figure}

Der erste Teil beschreibt die konkrete analytische Funktion, die auf die Ergebnismenge
ausgeführt wird. Hier besteht die größte Parallelität zu den klassischen
Aggregatfunktionen. Eine grobe Übersicht über verschiedenen \textit{Window
Functions} beschreibt \cite{ibrahaim23} in seiner Arbeit. Hierzu unterteilt er im
Kapitel \textit{Different Types of Window Functions} die möglichen Funktionen
übersichtlich in drei verschiedenen Gruppen,

Das Schlüsselwort \texttt{OVER(*)} wurde bereits zuvor in diesem Artikel erwähnt.
Es ist der namensgebende Teil der \textit{Window Functions}, da so die Fenster
über die Ergebnismenge gelegt werden.

Im Argument der \texttt{OVER} Funktion definieren wir die Ausprägung des Fensters
und die Ordnung des Fensters. Dieses Argument ist bekannt als \textit{analytic-clause}
und teilt sich laut \cite{oracle} wieder in weitere Teile auf. Der Aufbau dieser
\textit{analytic-clause} sei hier beschrieben, bleibt aber hier unkommentiert.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.5]{img/aufbauAnalyticClausel.jpg}
	\caption{ Aufbau einer analytischen Klausel | Quelle: \cite{oracle}}
\end{figure}

% --------------------------------------------------------------------------------------------

\section{Common Table Expressions und rekursive Queries}
Neben den \textit{Window Functions} sollen hier noch die rekursiven Abfragen,
auch \textit{Recursiv Queries} genannt, behandelt werden. Um eine rekursive Abfrage
schreiben zu können, muss zunächst ein anderes Konzept in SQL verstanden werden.
Die rekursiven Abfragen bauen auf diesem Konzept auf und sind ohne dies nicht einsetzbar.
Die Rede ist von den \textit{Common Table Expressions (CTE)}.

Der erste Abschnitt dieses Kapitels führt demnach in die Theorien und Konzepte der
\textit{CTE} ein und baut darauf auf. Im zweiten Schritt sollen die rekursiven Abfragen
betrachtet werden.

\subsection{Common Table Expressions (CTE)}
Die \textit{Common Table Expressions} sind ein mächtiges Konstrukt in SQL und
vereinfachen komplexe Anfragen. Speziell Abfragen mit einem \textit{subselect}
werden dadurch deutlich einfache.

Für eine aussagekräftige Definition der \textit{CTE} sei auf den Internetartikel
von \cite{Ignacio2022} verwiesen, der die Frage: "Was ist eine \textit{CTE}" mit
folgendem Satz beantwortet:
\begin{center}
	\textit{ 'A Common Table Expression (CTE) is like a named subquery. It functions
	as a virtual table that only its main query can access. CTEs can help simplify,
	shorten, and organize your code.' } \\ \cite{Ignacio2022}
\end{center}
Vereinfacht lässt sich daraus ableite, dass ein CTE ein query mit Namen ist. Es handelt
sich hier also um ein \texttt{SELECT}, das mit einem Namen angesprochen werden kann.
Betrachtet wird es als virtuelle Tabelle, da diese erst zur Laufzeit des jeweiligen
\texttt{SELECT} angelegt wird und nach Abschluss sofort zerstört wird. Einmal erstell,
kann so eine Virtuelle Tabelle wie eine herkömliche Tabelle behandelt werden. Die
\textit{main query}, die \cite{Ignacio2022} anspricht, ist das \texttt{SELECT} Statement,
dass direkt nach der CTE Erstellung folgt. Das CTE leitet also eine kleine Abstraktionsschicht
ein, die hilft, die Vorteil, die aus der Definition von \cite{Ignacio2022}
hervorgehen, einzuhalten.

Ein CTE bedient sich folgender Syntax:

\texttt{WITH cteName (<...>) SELECT mainQuery FROM cteName;}

Für \texttt{cteName} ist der entsprechende Name für die virtuelle Tabelle zu
wählen. Die \texttt{(<...>)} weist darauf hin, dass in der runden Klammer das jeweilige
\texttt{SELECT} Statement steht, welches die Identität der CTE festlegt. \texttt{mainQuery}
ist die Query, die auf die virtuelle Tabelle verweist und unmittelbar nach der
CTE folgt.

\subsection{Rekursive Queries}
Mit dem Wissen aus dem vorherigen Abschnitt soll hier in die rekursiven Abfragen
eingeführt werden. Eine Rekursion ist laut \cite{benecke1998rekursion} Kapitel zehn
(Rekursion) die Definition eines Problems, einer Funktion oder eines Verhaltens
durch sich selbst. Er schreibt weiter, dass der Begriff Rekursion in der
Informatik oft im Zusammenhang mit Datenstrukturen und Funktionen steht. Dies Trifft
auch auf die CTE. Diese werden Verwendendet um innerhalb einer CTE auf sich
selbst zu referenzieren und so einen rekursiven Aufruf generieren.

\begin{lstlisting} [caption={Rekrusive Abfragen mit CTE | Quelle: \cite{Mohan23}}, label={list:rekursion}]
WITH RECURSIVE cteName -- define CTE
AS (SELECT <...> -- base case
	FROM <...>
	UNION ALL -- combine
	SELECT <...> -- recursive case
	FROM cteName
)
SELECT * FROM cteName; -- main query
\end{lstlisting}

Das Beispiel aus \ref{list:rekursion} soll den grundsätzlichen Aufbau einer rekursiven
Abfrage zeigen. Wie auch \cite{Mohan23} in seinem Beispiel schon beschrieben hat,
wird zunächst die virtuelle Tabelle (CTE) mit Name definiert. Innerhalb der CTE
gibt es zwei \texttt{SELECT} Statements. Einen \textit{Base Case} und einen \textit{Recursiv
Case}. Die Rekursion entsteht hier im zweiten \texttt{SELECT}, dass auf den CTE referenziert.
Der \texttt{UNION ALL} kombiniert die beiden \texttt{SELECT}. Die \textit{main
query} ist Teil der klassischen CTE und wurde im obrigen Kapitel bereits
behandelt. Es wird hier genutzt um letzten Endes das Ergebnis, dass in der CTE
zusammengebaut wurde, auszugeben.

% --------------------------------------------------------------------------------------------

\section{Rollup and Cube}
Auch die letzte Analyse-Erweiterung die in diese Arbeit behandelt werden soll, macht
ihrem Namen alle Ehre und gewährt mit wenigen Zeilen Quelltext, eine viel
analytischere Einsicht in die Ergebnismenge, als es mit herkömmlichen SQL-Befehlen
möglich ist.

Die Konzepte, \texttt{ROLLUP} und \texttt{CUBE} sind Erweiterungen der \texttt{GROUP
BY} Klausel und wie bereits in früheren Kapitel beschrieben speziell für die Datenanalyse
geeignet. Wie bei den rekursiven Abfragen basiert diese Erweiterung auf einem
Grundkonzept, dass an dieser Stelle vorangehen soll.

QUELLE FEHLT

\subsection{Grouping Sets}
Das Schlüsselwort \texttt{GROUPING SETS} ist ebenfalls eine Erweiterung der herkömmlichen
\texttt{GROUP BY} Klausel. Wie aus dem Namen schon hervorgeht, handelt es sich
nicht um eine einzelne Gruppierung, sondern um ein ganzes Set an Gruppierungen.
Das Set lässt darauf deuten, dass jede Gruppierung nur einmal vorkommt.
\cite{oracle16} beschreibt, dass dieses Schlüsselwort mehrere Gruppierungen in einer
Abfrage erlaubt. Sie beschreiben weiter, dass bei einem \texttt{GROUPING SET}
nur die eine angegebene Gruppe gruppiert wird und nicht alle möglichen Gruppen. \cite{oracle16}
verweist an dieser Stelle schon auf die Erweiterungen \texttt{ROLLUP} und
\texttt{CUBE}.

\texttt{GROUP BY GROUPING SETS (continent, city);}

Dieses kurze Beispiel zeigt eine mögliche Syntax. Die Ergebnismenge dieser
Gruppierung ist einmal die Gruppierung nach dem \textit{continent} und einmal nach
\textit{city}. Es werden keine Kombinationen gruppiert, nur die einzelnen
Spalten. Zu erwähnen ist hier, dass dies nur eine Möglichkeit von vielen ist, ein
\texttt{GROUPING SETS} zu verweden.

\subsection{Rollup}

\subsection{Cube}

% --------------------------------------------------------------------------------------------

\section{Dialekte und Unterstützung}
Wird nur ausgeschrieben, wenn wir noch Seiten benötigen